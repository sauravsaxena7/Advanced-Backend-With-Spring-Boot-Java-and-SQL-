# 17. JAVA:  COLLECTION FRAMEWORK IN DEPTH.

1. **What is Java Collection Framework?**
*   Added in java verision1.2.
*   Collections is nothing but group of Objects.
*   Present in java.util package.
*   \-Framework provide us the architecture to manage these "group of object's" i.e. add, update, delete, search etc.
2. **Why we need Java Collections Framework?**
*   Prior **JCF**, we have Array, Vector, Hash tables.
*   But problem with that is, there is no common iterface, so, it's difficut to remeber the methods for each.

```java
public class Main{
  public static void main(String[] args){
      int a[] = new Int[4];
      //inset an element in an array
      a[0] = 1;
      //get front element
      int frontVal = a[0];
      Vector<Integer> v = new Vector();
      v.add(1);
      frontVal=v.get(0);
   }
}
```

  

1. **Java Collections Framework Hierarchy.**

  

![](https://t9016373936.p.clickup-attachments.com/t9016373936/4effd0b1-e911-42f7-a22e-15a0e6696c2e/image.png)

  

![](https://t9016373936.p.clickup-attachments.com/t9016373936/ec936a74-2093-4579-b423-b708329b65fc/image.png)

  

1. **Iterable.**
*   Used to TRAVERSE the collection.

| [**S.NO**](http://S.NO) | **METHODS** | **JAVA VERSION** | **Usage** |
| ---| ---| ---| --- |
| 1. | **iterator()** | **Java 1.5** | it returns the iterator object, which provides below methods to iiterate the collection.<br>**hasNext()**<br>➝Returns **true** if collection has more elements.<br>**next()**<br>➝Return next element in iteration.<br>**remove()**<br>➝Removes Last element returned by iterator.<br> |
| 2. | **forEach()** | **Java 1.8** | Iterate collection using **Lambda Expression**.<br>**Lambda Expression** is called for each element.<br> |

```java
public class Main{
  public static void main(String[] args){
      List<Integer> list = new ArrayList<>();
      list.add(1);
      list.add(2);
      list.add(3);
      list.add(4);
      System.out.println("Iterating the value using iterator method");
      Iterator<Interger> it = new list.iterator();
      while(it.hasNext()){
         int val = it.next();
         System.out.println(val);
         if(val == 3){
            it.remove();
         }
         
      }
      System.out.println("Iterating the value using for loop");
      for(int val : list){
         System.out.println(val);
       }
       System.out.println("Testing for-each method loop");
       list.forEach((ele)->System.out.println(ele));
   }
}
output:
Ierating the value using iterator method
1
2
3
4
Iterating the values using advance for loop
1
2
4
Testing for-each loop
1
2
4
```

**NOTE:-**

> 1\. Here **Java collection** comes in the **java 1.2** and **collection** itself contain **iterator()** method .  
> 2\. But **Iterable** comes In **java 1.5** so, **Iterable** act as a **parent of Collection** so, that's why **Iterable** need to contain **iterator() method.**  
> 3\. Before **Java 1.5** we are using **iterator** method to **iterate collection**.

  

1. **Collection.**
*   It represents the group of objects.
*   It's an interface which provides methods to work on group of objects.
*   Below are the most common used methods which are implemented by its child classes like ArrayList, Stack, LinkedList etc.

| [**S.NO**](http://S.NO) | **METHODS** | **JAVA VERSION** | **Usage** |
| ---| ---| ---| --- |
| 1. | size() | Java 1.2 | it returns the total number of elements present int the collection. |
| 2. | isEmpty() | Java 1.2 | Used to check the if collection is empty or has some value it returns true or false. |
| 3. | contains() | Java 1.2 | Used to search an element in the collection, return true / false. |
| 4. | isEmpty() | Java 1.2 | It convert collection into an array. |
| 5. | add() | Java 1.2 | Used to insert an element in the Array. |
| 6. | remove() | Java 1.2 | Used to remove an element from collection. |
| 7. | addAll() | Java 1.2 | Used to insert one collection in another collection. |
| 9. | removeAll() | Java 1.2 | Remove all the elements from collections which are present in the collection passes in the parameter. |
| 9. | clear() | Java 1.2 | Remove All the elements from the collection. |
| 10. | equals() | Java 1.2 | Used to check if 2 collection are eqal or not. |
| 11. | stream()<br>and<br>parallelStream() | Java 1.8 | Provides effective way to work with collection like filtering, proceesing data etc. |
| 12. | iterator() | Java 1.2 | Used to ierate the elements before Iterable , Iterable added in java 1.5 version. |

  

1. **Collection VS Collections**
*   Collection is apart of Java Collection Framework. And it's an interface, which expose various methods which implemented by various collection class like Arraylist,stack,LinkedList etc.
*   Collections is **Utility class** and provide static methods, which are used to operate on collection like swapping,searching,reverse , copy etc.

➝**Methods**: **sort(), binarySearch(), get(), reverse(),**

**shuffle(),swap(), copy(), min(), max(), rotate()**

> In **Utiltiy Class** all methods are static.

  

```java
public class Main{
  public static void main(String[] args){
      List<Integer> list = new ArrayList<>();
      list.add(1);
      list.add(2);
      list.add(3);
      list.add(4);
      System.out.println("max value: "+Collections.max(list));
      System.out.println("minvalue: "+Collections.min(list));
       Collections.sort()
       
   }
}
```

  

1. **Queue.**
*   lt is an iterface and chile of collection interface.
*   It is follow FIFO approach but there is exception like PriortyQueue.

  

| [**S.NO**](http://S.NO) | **METHODS** | **Usage** |
| ---| ---| --- |
| 1. | add() | Insert the element into the queue.<br>True if insrtion is succesfull and **Exception** if insertion is fail.<br>Null element insertion is not allow will throw \[NPE\] NullPointerException.<br> |
| 2. | offer() | Insert the element into the queue.<br>True if insrtion is succesfull and **False** if insertion is fail.<br>Null element insertion is not allow will throw \[NPE\] NullPointerException.<br> |
| 3. | poll() | Retrives and Removes the head of the queue.<br>Returns null if queue is empty.<br> |
| 4. | remove() | Retrives and Removes the head of the queue.<br>**Exception NoSuchElementElementException** If Queue is Empty.<br> |
| 5. | peak() | return head of the element without removing it.<br>Return null if queue is empty.<br> |
| 6. | element() | Retrives the value present at the head of the queue but do not removes it.<br>Returns an Exception \[NoSuchElementException\] if queue is empty.<br> |

  

1. **PriorityQueue.**
*   It's implement Queue Interface.
*   It based on priority Heap \[ Max Heap and Min Heap\].
*   Elements are ordered according to either Natural Ordering \[By default\] or By Comparator provided during queue Construction time.

  

**MIN PRIORITY QUEUE.**

```java
public class Main{
  public static void main(String[] args){
      //Internall it's uses min heap
      //Integer -> ascending
      //String - > lexicographically
      PriorityQueue<Integer> minQ= new PriorityQueue<>();
      minQ.add(5);
      minQ.add(2);
      minQ.add(8);
      minQ.add(1);
      minQ.forEach((Interger val)->System.out.println(val));
      while(!minQ.isEmpty()){
         int val = minQ.poll();
         System.out.println("remove from top: "+val);
         
      }
   }
}
output
1
2
8
5
remove from top: 1
remove from top: 2
remove from top: 5
remove from top: 8
```

  

**MAX PRIORITY QUEUE.**

```java
public class Main{
  public static void main(String[] args){
      //Internall it's uses max heap
      //Integer -> decendin
      //String - > lexicographically reverse
      PriorityQueue<Integer> minQ= new PriorityQueue<>((Integer a, Interger b)->b-a);
      minQ.add(5);
      minQ.add(2);
      minQ.add(8);
      minQ.add(1); 
      minQ.forEach((Interger val)->System.out.println(val));
      while(!minQ.isEmpty()){
         int val = minQ.poll();
         System.out.println("remove from top: "+val);
         
      }
   }
}
output
8
5
2
1
remove from top: 8
remove from top: 5
remove from top: 2
remove from top: 1
```

  

**Time Complexity:**

add() and offer(): O(logn)

peak() : O(1)

poll() and Remove head element :O(logn)

Remove arbitrary element : O(n)

  

1. **Comparator V/S Comparable.**
*   Comparator and Comparable both provides a way to sort the collection objects.

  

```java
public class Main{
  public static void main(String[] args){
      int[] array = {1,2,3,4}
      Arrays.sort(array);
   }
}
```

  

```java
public static void main(@NotNull int[] a){
   DualPivotQuicksort.sort(a,0,a.lenght-1,null    
}


```

*   There is no way we can sort in decending order.
*   **Object Collection Sorting.**

```java
public class Car{
   String name;
   String type; 
}
```

  

```java
public class Main{
  public static void main(String[] args){
      Car[] array = new Car[3];
      car[0] = new Car("SUV","petrol");
       car[0] = new Car("Sedan","diesel");
        car[0] = new Car("HatchBack","CNG");
        Arrays.sort(array);
     
   }
}
//Throw exception Car cannot be cast to java.lang.Comparable.
```

*   Only Primitive type sorting allowed not collection type sorting.

  
  
  

**What is Deque.**

*   Stands for Double Ended Queue. Means addition and removal can be done from both the sides of the queue.

**Methods available in Deque interface.**

Queue:

add(), offer(), poll(), remove(), peek(), element()

  

**Deque:**

  

|  | Throw Exception | Do Not Throw Exception | Throw Exception | Do Not Throw Exception |
| ---| ---| ---| ---| --- |
| Insert Operations | addFirst(e) | offerFirst(e)<br>return true/false | addLastt(e) | offerLast(e)<br>return true/false<br> |
| Remove Operations | removeFirst(e) | pollFirst(e)<br>return true/false | removeLast() | pollLast(e)<br>return true/false<br> |
| Examine Operations | getFirst() | peekFirst(e)<br>return true/false | getLast() | peekLast(e)<br>return true/false<br> |

  

**Using this methods, we can even use Deque to implement STACK \[LIFO\] and QUEUE \[FIFO\] both.**

*   To use it as Stack, push() and pop() method are available.
*   push()➝ Internally calls addFirst()
*   pop() ➝ Internally call removeFirst()

**What About the prvious Method which already has Queue Interface.**

*   add() ➝ Internally calls addFirst() method.
*   offer() ➝ Internally calls offerFirst() method.
*   poll() ➝ Internally calls pollFirst() method.
*   remove() ➝ Internally calls removeFirst() method.
*   peek() ➝ Internally calls peekFirst() method.
*   element() ➝ Internally calls getFirst() method.

  

**ArrayDeque.**

*   ArrayDeque \[ Concrete class \], implements the methods which are available in queue and Dequeue Interface.

  

```java
 public class Main{
  public static void main(String[] args){
      ArrayDeque <Integer> arrayDequeAsQueue  = new ArrayDeque<>();
      arrayDequeAsQueue.addLast(1);
     arrayDequeAsQueue.addLast(2)
      arrayDequeAsQueue.addLast(3)
      //Deletion
      int element = arrayDequeAsQueue.removeFirst();
      
      System.out.println(element);
      //LIFO Last In First Out
      ArrayDeque <Integer> arrayDequeAsStack  = new ArrayDeque<>();
      arrayDequeAsStack.addFirst(1);
     arrayDequeAsStack.addFirst(2)
      arrayDequeAsStack.addFirst(3)
      //Deletion
      int removedEle = arrayDequeAsStack.removeFirst();
      System.out.println(removeElem);
   }
}
```

  

**Time Complexit For ArrayDeque.**

*   Insertion **atfirst and atEnd** : Amortized \[ Most of the time or Average \] complexity is O(1) except fwe cases like When array resize it copy all the alement into new arrayQueue and then insert new element as per instruction.
*   O(n):Whene queue size thershold reached and try to insert an element at end or front then , then its O(n) for bigger size.
*   Deletion: O(1)
*   Search: O(1) ➝Examine Operation.

**Space Complexity: O(n)**

  
  

**Thread Safe:**

*   When Multiple thread try to access or Update like insertion and deletion in Multithreade Environment. then Queue might act as **Inconsistent**

  

| **Collection till now** | **isThreadSafe()** | **Maintains Insertion Order** | **Null Elements Allowed** | **Duplicate Elements Allowed** | **Thread Safe Version** |
| ---| ---| ---| ---| ---| --- |
| Priority Queue | NO | NO | NO | YES | **PriorityBlockingQueue**<br><br>PriorityBlockingQueue<Integer> pbq = new PriorityBlokingQueue<>();<br>pbq.add(4);<br>pbq.add(3);<br>System.out.println(pbq.peek()); |
| ArrayDeque | NO | YES | NO | YES<br> | **ConcurrentLinkedQueue**<br><br>PriorityBlockingQueue<Integer> pbq = new PriorityBlokingQueue<>();<br>pbq.add(4);<br>pbq.add(3);<br>System.out.println(pbq.peek());<br> |

  
  

**List.**

*   List is a ordered collection of an Object. In which duplicate are allowed.

  

**How does it differ from Queue?**

*   Queue is also a collection of an Object but in queue insertion/removal/access can only happen either at start or end while in list data can be inserted, removed or access from anywhere.
*   In list, user can decide where to insert or access using index \[Start from 0\]
*   Internall used data structure is array.

  

**Methods Present In List.**

*   In List it has already all methods of collection like size(), isEmpty(), contains(), toArray(), add(E element), addAll(Collection c), removeAll(Collection c), clear(), equals(), stream() and parallelStream(), iterator()

  

| [**S.NO**](http://s.no/) | **METHODS** | **Usage** |
| ---| ---| --- |
| 1. | add(int index, E element) | Insert Element At spcific position in the list.<br>If element is alrady at the position . that element will be shifted right to it's element.<br> |
| 2. | addAll(int index, Collection c) | Insert all the element of specified collection into that list at specific conditions into this list at specific index, and shift the element at this index and subsquent element to the right.<br> |
| 3. | replaceAll(UninaryOperator op) | Replace each element of the list, with the result of applying the operator to the element<br> |
| 4. | sort(Comparator c) | Sort based on the order provided by the comparator.<br> |
| 5. | get(int index) | Return the element at specified posititon.<br> |
| 6. | set(int index, Element e) | Replace the element at specific index in the list with the element provided.<br> |
| 7. | remove(int index) | Remove the element from the index and shift subsiquent element to left.<br> |
| 8. | indexOf(Object o) | Return the index of the first occurence of the specified element in the list.<br>2\. -1 if list doesnot contains the element . |
| 9. | lastIndexOf(Object o) | Return the index of last occurence object specifies in the list<br>\-1 if dowsnot exit. |
| 10. | ListIterator<E> listIterator() | list **iterator** return the object of ListIterator.<br>ListIterator (interface) extends from the **Iterator** iterface.<br>It has all the methods which are available in iterator and helps us to iterate in forward direction like.<br>hasNext()<br>Returns true, If there are more element in collections<br>2\. next()<br>return the next element in the iteration.<br>3\. remove()<br>Removes the the last element return iterator.<br><br>**+**<br><br>New Methods which are introduced in ListIterator, which help to iterate in backward direction:<br>boolean hasPrevious()<br>➝ Return true, if there are more elements in the list while traversing in reverse order. else throw exception.<br>2\. E previous() Return the previous element and move the cursor position backward.<br>3\. int nextIndex()<br>➝Return the index of the previous element<br>➝ Return -1 of the list, if the list if it's at begining of the list.<br>4\. int nextIndex()<br>➝Return index of the next element.<br>➝return size of the list, if it's at end of the list.<br>5\. int previousIndex()<br>➝Return index of the previous element .<br>➝ return -1 of the list, if it's at beining of the list.<br>6\. set(E e) Replaces the last element returned by next or previous with sprcified element.<br>7\. add(E e)<br>➝ Insert the specified element immediately before the element that would be returned by the next and after the element that would be returned by the previous.<br><br> |
|  | ListIterator<E> listIterator(int index) | start the iterator from the specified index.<br>specified index indicates the first element that would be returned by an initial call to next. |
|  | List<E> subList(int fromIndex, int toIndex) | return the portion of the list.<br>fromindex-Inclusive<br>toIndex - Exclusive<br><br>if formIndex == toIndex return sublist is Empty.<br>Any chnages in sublist , will change in main list also and vice vers. |

  

![](https://t9016373936.p.clickup-attachments.com/t9016373936/53d5ce11-52f4-4a84-b2e8-2e03ae7a426c/addwhilelistiterator.PNG)

  

```java
package CollectionFramework;

import java.util.*;

public class ArrayListExample {
    public static void main(String[] args){

        //add(int index,E e)
        List<Integer> list1 = new ArrayList<>();

        list1.add(0,1);
        list1.add(1,2);
        list1.add(2,3);
        list1.add(4,3);

        System.out.println("list1: "+list1);

        //addAll(int index Collection c);
        List<Integer> list2 = new ArrayList<>();
        list2.add(0,9);
        list2.add(1,10);

        list1.addAll(0,list2);

        System.out.println("list1+list2 at 0 index: "+list1);

        //replace all
        list1.replaceAll((val)->val+1);
        System.out.println("list1.replaceAll((val)->val+1): "+list1);

        //sort
        Comparator<Integer> myComp = new Comparator<Integer>() {
            @Override
            public int compare(Integer o1, Integer o2) {
                return o1-o2;
            }
        };
        list1.sort(myComp);

        System.out.println("list1.sort(myComp): "+list1);
        System.out.println("list1.get(3): "+list1.get(3));

        list1.set(1,-9000);

        System.out.println("list1.set(0,-9000): "+list1);

        list1.remove(1);
        System.out.println("list1.remove(1): "+list1);

        System.out.println("list1.lastIndexOf(3): "+list1.lastIndexOf(3));

        //ListIterator
        //need to provide the index in listiterator , from where it has to start

        ListIterator<Integer> listIterator1 = list1.listIterator(list1.size());

        //traversing backward direction
        while(listIterator1.hasPrevious()){
            int prevEle = listIterator1.previous();
            System.out.println("traversing backward: "+prevEle+" nextIndex: "+listIterator1.nextIndex()+ " prevIndex: "+listIterator1.previousIndex());
            if (prevEle==-9000){
                listIterator1.set(-5000);
            }
        }

        System.out.println("after traversing and setting backward direction"+list1);

        //Traversing in forward direction
        ListIterator<Integer> listIterator2 = list1.listIterator();

        while (listIterator2.hasNext()){
            int val = listIterator2.next();
            System.out.println("traversing forward: "+val+" nextIndex: "+listIterator1.nextIndex()+ " prevIndex: "+listIterator2.previousIndex());

            if(val ==-5000){
                listIterator2.add(-9000);
            }
        }
        System.out.println("after traversing and setting forward direction: "+list1);


        List<Integer> subList = list1.subList(3,6);
        System.out.println("list1.subList(3,6): " + subList);






    }
}

output:-
list1: [1, 2, 3, 3]
list1+list2 at 0 index: [9, 10, 1, 2, 3, 3]
list1.replaceAll((val)->val+1): [10, 11, 2, 3, 4, 4]
list1.sort(myComp): [2, 3, 4, 4, 10, 11]
list1.get(3): 4
list1.set(0,-9000): [2, -9000, 4, 4, 10, 11]
list1.remove(1): [2, 4, 4, 10, 11]
list1.lastIndexOf(3): -1
traversing backward: 11 nextIndex: 4 prevIndex: 3
traversing backward: 10 nextIndex: 3 prevIndex: 2
traversing backward: 4 nextIndex: 2 prevIndex: 1
traversing backward: 4 nextIndex: 1 prevIndex: 0
traversing backward: 2 nextIndex: 0 prevIndex: -1
after traversing and setting backward direction[2, 4, 4, 10, 11]
traversing forward: 2 nextIndex: 0 prevIndex: 0
traversing forward: 4 nextIndex: 0 prevIndex: 1
traversing forward: 4 nextIndex: 0 prevIndex: 2
traversing forward: 10 nextIndex: 0 prevIndex: 3
traversing forward: 11 nextIndex: 0 prevIndex: 4
after traversing and setting forward direction: [2, 4, 4, 10, 11]
list1.subList(3,6): [4, 4, 10]


```

  

**TimeComplexity:**

*   Insertion

➝O(1): when inserting the element at the end of the array, And space is sufficient.

➝O(N) when inserting an element at particular index of the array, then it require shifting of the values.

➝O(n) : when array sized thershold reached and try to insert an element at end, then also its O(N) as values are copied to new array wiith bigger size

*   Deletion: O(N) we have to shift the values.
*   Search : O(1)

Space complexity:

O(N)

  
  
  
  

**Thread Safe:**

  

| **Collection till now** | **isThreadSafe()** | **Maintains Insertion Order** | **Null Elements Allowed** | **Duplicate Elements Allowed** | **Thread Safe Version** |
| ---| ---| ---| ---| ---| --- |
| ArrayList | YES | YES | YES | YES |  |

  
  

**LinkedList.**

*   LinkedList implements both deque and list interface
*   Means it support dequeue methods like: getFirst(), getLast(), removeFirst(), removeLast()

  

```java
package CollectionFramework;

import java.util.LinkedList;

public class LinkedListExample {
    public static void main(String[] args){
        LinkedList<Integer> list = new LinkedList<>();

        //using deque functionality
        list.addLast(200);
        list.addLast(300);
        list.addLast(400);
        list.addLast(500);
        list.addLast(100);

        System.out.println("list: "+list);

        System.out.println("list.getFirst(): "+list.getFirst());

        //using list functionality
        LinkedList<Integer> list2 = new LinkedList<>();

        list2.add(0,100);
        list2.add(1,300);
        list2.add(2,400);
        list2.add(1,200);

        System.out.println("list2: "+list2);

    }
}
output:
list: [200, 300, 400, 500, 100]
list.getFirst(): 200
list2: [100, 200, 300, 400]

Process finished with exit code 0


```

  
  

**TimeComplexity:**

*   Insertion at start O(1)
*   Insertion at particular index: O(n) for lookup of the the index + O(1) for adding.
*   Search O(n)
*   Deletion at start O(1)
*   Deletion at specific index: (n) for lookup of the index +O(1) for removal
*   Space complexity: O(N)

  

**Thread Safe:**

  

| **Collection till now** | **isThreadSafe()** | **Maintains Insertion Order** | **Null Elements Allowed** | **Duplicate Elements Allowed** | **Thread Safe Version** |
| ---| ---| ---| ---| ---| --- |
| LinkedList | NO | YES | YES | YES | **CopyOnWriteArrayList**<br><br>public class Test{<br>public static void main(String args\[\]){<br>List<Integer> list = new CopyOnWriteArrayList<>();<br>list.add(0,100);<br>System.out.println(list.get(0));<br>}<br>}<br> |

  
  

**Vector**:

*   Exactly same as arrayList, elements can be access vis index;
*   \- But it's thrad safe
*   Puts lock when operations is performed on vector.
*   less efficient then arraylist as for each operation it do lock/unlock internally

```java
package CollectionFramework;

import java.util.Vector;

public class VectorExample {
    public static void main(String[] args){
        Vector<Integer> v = new Vector<>();
        v.add(9);
        System.out.println("vector: "+v);
    }
}
output:
vector: [9]

Process finished with exit code 0
```

  

**Thread Safe:**

  

| **Collection till now** | **isThreadSafe()** | **Maintains Insertion Order** | **Null Elements Allowed** | **Duplicate Elements Allowed** | **Thread Safe Version** |
| ---| ---| ---| ---| ---| --- |
| LinkedList | NO | YES | YES | YES | **CopyOnWriteArrayList**<br><br>public class Test{<br>public static void main(String args\[\]){<br>List<Integer> list = new CopyOnWriteArrayList<>();<br>list.add(0,100);<br>System.out.println(list.get(0));<br>}<br>}<br> |

  

**Stack**.

*   Represent LIFO \[Last In First Out\] operation
*   Since it extends Vector, it's method is also Synchronizes
*   How it's different from Deque is not thread safe, stack is.

  

```java
package CollectionFramework;

import java.util.Stack;

public class StackExample {
    public static void main(String[] args){
        Stack<Integer> stack = new Stack<>();
        stack.push(2);
        stack.push(0);

        System.out.println("stack: "+stack);
        System.out.println("stack.pop(): "+stack.pop());
        
    }
}
output:
stack: [2, 0]
stack.pop(): 0

Process finished with exit code 0
```

  

**TimeComplexity:**

*   Insertion O(1)
*   Deletion O(1)
*   Search:O(n)
*   Space complexity: O(N)

  

**Thread Safe:**

  

| **Collection till now** | **isThreadSafe()** | **Maintains Insertion Order** | **Null Elements Allowed** | **Duplicate Elements Allowed** | **Thread Safe Version** |
| ---| ---| ---| ---| ---| --- |
| Stack | YES | NO | YES | YES | N/A<br> |

  
  

**Map Properties**:

*   It's an interface and it's implementation are:

➝HashMap: do not maintain the order.

➝HashTable: Synchronized version of HashMap

➝LinkedHashMap: Maintain the insertion order.

➝TreeMap: sorts the data internally.

*   Object that maps key to values
*   \- Can contain duplecate key.

Methods Available In Interface.

  

| [**S.NO**](http://s.no/) | **METHODS** | **Usage** |
| ---| ---| --- |
| 1. | size() | it returns the total number of of key-value mapping present. |
| 2. | isEmpty() | true: if map contains no key-value mappine else fasle. |
| 3. | containsKey(Object key) | if given key is already present in map return true else flase |
| 4. | containsValue(Object value) | return true if one or more key mapped to the specified value. |
| 5. | get(Object key) | return the value to which this key is mapped. |
| 6. | put(K key,V value) | If map:<br>Already has some key present:It will overwrite thw value noe provided<br>do not have the key present: it will add new key-value mappings.<br> |
| 7. | remove(Object Key) | removes the key-mapping from the map for the specified |
| 9. | putAll(Map<K,V> mp) | Remove all the elements from collections which are present in the collection passes in the parameter. |
| 9. | clear() | Remove All the elements from the collection. |
| 10. | Set<K> keySet() | Used to check if 2 collection are eqal or not. |
| 11. | Collection<V> values() | Provides effective way to work with collection like filtering, proceesing data etc. |
| 12. | Set<Map.Entry<K,V>> entrySet() | Used to ierate the elements before Iterable , Iterable added in java 1.5 version. |
| 13. | getOrDefault(key,defaultValue) |  |
| 14. | Entrysub-interface |  |

  

**HashMap**:

*   Can store null key or value \[HashTable do not contains null key or value\]
*   HashMap do not maintain inserton order
*   It's not thread safe \[Instead used ConcurrentHasMap or HashTable for thread safe HasMap implementation\]

  

What we have to learn in Hash Map:

*   Load Factor.
*   Entry<K,V> interface
*   Re-hashing
*   Performance

**Entry it is a sub-interface of Map.**

```java
interface Entry<K, V> {
       
        K getKey();

        V getValue();

       
        V setValue(V value);

      
        boolean equals(Object o);

     
        int hashCode();
        //many more methods ahead which is not mention
}
```

  
  

**Node<K,V>** present as nested class in **HashMap:**

  

```java
 /**
  public class HashMap<K,V> extends AbstractMap<K,V>
    implements Map<K,V>, Cloneable, Serializable {
**/
static class Node<K,V> implements Map.Entry<K,V> {
        final int hash;
        final K key;
        V value;
        Node<K,V> next;

        Node(int hash, K key, V value, Node<K,V> next) {
            this.hash = hash;
            this.key = key;
            this.value = value;
            this.next = next;
        }

        public final K getKey()        { return key; }
        public final V getValue()      { return value; }
        public final String toString() { return key + "=" + value; }

        public final int hashCode() {
            return Objects.hashCode(key) ^ Objects.hashCode(value);
        }

        public final V setValue(V newValue) {
            V oldValue = value;
            value = newValue;
            return oldValue;
        }

        public final boolean equals(Object o) {
            if (o == this)
                return true;

            return o instanceof Map.Entry<?, ?> e
                    && Objects.equals(key, e.getKey())
                    && Objects.equals(value, e.getValue());
        }
    }


```

  

**Without Defining Any Capacity It will be default one.**

**Map<K,V> mp = new HashMap<>();**

```java
/**
 * The default initial capacity - MUST be a power of two.
 */
static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16
```

  

In HashMap for hashing Alogorithms like :

*   SHA256
*   MD1

  

```java
Map<Integer,String> mp = new HashMap<(3);
mp.put(1,"SAURAV");
```

  

*   For Key **1** we need to **compute Hash**.
*   Let's we are taking 1234567 % **SIZE OF THE TABLE .**
*   key➝1 ➝ 1234567 % 3
*   After doing hashing for particular key it gives some index. within the range of 0 to 3 becacause size of the table we are taking is 3.
*   let's Index will come like 1. At index 1 in table we need to put all values like hash, key, value and next.

```java
//Let's Put 
mp.put(5,"GAURAV");
```

*   Again we are going to calculate Hash like: 94520897.
*   KEY➝5➝ 94520897 % 3.
*   Index will come like 2. all Node value store at index 2.

**Now we are talking about collision**.

*   What if an index will come and that index already contain or store some node vaue.

```java
//Let's Put 
mp.put(10,"SAROJ");
```

*   Calculating Hash will be let's 515100.
*   KEY ➝ 10 ➝ 515100 % 3
*   INDEX WILL COME LIKE : **1**
*   we have already stored node value of KEY ➝ 1.
*   Internall it will check whether KEY ➝ 10 Present or not In Table INDEX 1 OR TRY to check whether both keys are same or not.
*   IF above condition is not true.
*   Then it will create new node

![](https://t9016373936.p.clickup-attachments.com/t9016373936/04530a30-f542-4a8f-94a1-ed66fcf7f942/image.png)

*   In case of collision it will grow horizontall usinsg data structure linked list and next address will be saved.

  

![](https://t9016373936.p.clickup-attachments.com/t9016373936/934c7e60-dea4-488e-8f87-b31b865be9e8/image.png)

  

**NOTE:**

*   Hash with actual key return always same index or always collision occurs that's because the key collide with same index it will store in the form linked list .
*   let's some key return some index after performing hashing we don't need search or compare thouse key with some **other index key** .

  

**Load Factor**.

*   **get**(10) ➝ hash ➝ 515100
*   515100 % 3 = index = 1
*   So, Key ➝ 10 ➝ might be present on index ➝ 1
*   so, internlly it will iterates index ➝ 1 linked list to find key ➝ 10
*   On that particular index if key matches any of node value for the key will return.

  

**Contract between hashCode & equal METHOD**.

*   **hashCode**() ➝ it will help while generating hash for a key.
*   **equal**() ➝ It will comparing Node objects whether two objects are equal or not while searching.

**What about Contract** ?

SO, Here contract say's there is two rule

1. IF two objects are equal \[obj1 == obj2\]
*   then there hash should be also equal or same.
*   For KEY ➝ 10 ➝ HASH ➝ ALWAYS BE SAME TO ➝ 515100
2. If 2 object's hash is same it doesn't mean their object's will be same \[obj1 != obj2\]
*   May be hash(6) and hash(5) are might be equal or not.

  

**HashMap OFFER AVERAGE TIME COMPLEXITY O(1) for insertion, deletion, upadte and for finding.**

**How's that possible ?**

*   There is one disadvantage here what if for every put() operation the hash will always return same index.
*   The linked list will grow horizontally for that particular index.
*   And all other index remain empty.

➝ index \[ 0 \] ➝1 ➝2 ➝3 ➝4 ➝5 ➝6 ➝...........................➝➝ n

*   for any operation it will take O(n)
*   **\[ WORST CASE TIME COMPLEXITY O(N) \]**

  

Now let's come to our original discussion about **LOAD FACTOR**.

  

```java
/**
 * The load factor used when none specified in constructor.
 */
//WHAT IS THIS?
static final float DEFAULT_LOAD_FACTOR = 0.75f;
```

  

*   Initial hash map size is 16 and load factor is .75f.
*   It's says when we multipliying size \* load factor
*   16\*0.75 =12
*   When 12 data or key-value mapping will be inserting into table.
*   when you inserting 13th element into table.
*   it will do re-hashing or double the size or increase the size of table
*   16 ➝ to ➝ 32 ➝ to ➝ 64 ➝ to ➝128 always multipliying by 2
*   after re-hashing, for previous key-value pair index get's changes that's called re -hashing because the size of table get's doubled it will goes index to 31th \[size is 32 so, 0 to 31\].
*   If size is small definately collision increases because while calculating index using hasing we are doing **mod** with size of table and linked list more grow in horizontally and all operation will take **O(N)** .

**IS Load Factor will guarantee that after increasing size of table get's lead to less collision**.

*   **NO**
*   In worst case after even increasing the size hashing may return same index again and again it will leads to more collision.

  

**TREEIFY\_THRESHOLD.**

```java
/**
 * The bin count threshold for using a tree rather than list for a
 * bin.  Bins are converted to trees when adding an element to a
 * bin with at least this many nodes. The value must be greater
 * than 2 and should be at least 8 to mesh with assumptions in
 * tree removal about conversion back to plain bins upon
 * shrinkage.
 */
static final int TREEIFY_THRESHOLD = 8;
```

  

*   while performing put() opertaion the index collide every time let's for 0 index.
*   At 0 index already linked list grow to it's threshold length **\[TREEIFY\_THRESHOLD = 8\]**
*   Again we want to store 9th element which also collide with index 0.
*   Bin count is length of linked list.
*   Then the liknked list convert into **Balanced Binary Search tree \[RED-BLACK TREE\]**
*   So, Searching would be **log(N).**
*   Why RED-BLACK **\[Balanced Binary Search tree\]**.
*   it's becasuse **AVL or Binary Search Tree** may grow in one direction only.

  

**BRIEF EXAMPLE WITH CODE:**

  

```java
package CollectionFramework.MapInterface;

import java.util.Collection;
import java.util.HashMap;
import java.util.Map;

public class HashMapExample {

    static void printHashMap(Map<Integer,String> mp){
        for(Map.Entry<Integer, String> map : mp.entrySet()){
            Integer key = map.getKey();
            String val = map.getValue();

            System.out.println("key: "+key+" value: "+val);
        }
    }
    public static void main(String[] args){
        Map<Integer,String> mp = new HashMap<>();
        mp.put(null,"i am null");
        mp.put(0, null);
        mp.put(1,"A");
        mp.put(-1,"Q");


        //compute if present
        mp.putIfAbsent(null,"lola");
        mp.putIfAbsent(0,"ZERO");
        mp.putIfAbsent(3,"c");

        printHashMap(mp);

        //isEmpty
        System.out.println("mp.isEmpty(): "+mp.isEmpty());

        //size
        System.out.println("mp.size(): "+mp.size());

        //size
        System.out.println("mp.containsKey(3): "+mp.containsKey(3));


        //get(key)
        System.out.println("mp.get(1): "+mp.get(1));

        //getOrDefault(key)
        System.out.println("mp.getOrDefault(1,'default value'): "+mp.getOrDefault(1,"default value"));

        //remove(key)
        System.out.println("remove(null)" + mp.remove(null));

        printHashMap(mp);

        //keySet()
        System.out.println("KeySet");
        for (Integer key : mp.keySet()){
            System.out.println("key: "+key);
        }


        //values()
        System.out.println("values");
        Collection<String> values = mp.values();
        for (String val : values){
            System.out.println("value: "+val);
        }





    }
}
output:
key: null value: i am null
key: 0 value: ZERO
key: -1 value: Q
key: 1 value: A
key: 3 value: c
mp.isEmpty(): false
mp.size(): 5
mp.containsKey(3): true
mp.get(1): A
mp.getOrDefault(1,'default value'): A
remove(null)i am null
key: 0 value: ZERO
key: -1 value: Q
key: 1 value: A
key: 3 value: c
KeySet
key: 0
key: -1
key: 1
key: 3
values
value: ZERO
value: Q
value: A
value: c

Process finished with exit code 0


```

  

**LinkedHashMap:**

*   Helps in Maintain insertion order or Helps in Maintain Access order.

➝1,2,3,4➝insertion order

➝Access means most frequently used let's you have used 3 recently.

➝then order will be like 1,2,4,3

*   Highly frequenly data will present at last.
*   less will be in first.
*   Similar to HashMap, but it uses Double LinkedList.
*   LinkedHashMap extends **HashMap** and Implements **MAP**

  

```java
public class LinkedHashMap<K,V>
    extends HashMap<K,V>
    implements SequencedMap<K,V>
{}
```

  
  

```java
/**
 * HashMap.Node subclass for normal LinkedHashMap entries.
 */
static class Entry<K,V> extends HashMap.Node<K,V> {
    Entry<K,V> before, after;
    Entry(int hash, K key, V value, Node<K,V> next) {
        super(hash, key, value, next);
    }
}
```

  
  

```java
map.put(1,"A");
map.put(21,"B");
map.put(23,"C");
map.put(141,"D");
map.put(25,"E");
```

  

![](https://t9016373936.p.clickup-attachments.com/t9016373936/e040f505-e860-4cac-a32a-2f219544d877/image.png)

  

**Here We are Maintaing Double Linked List also.**

  

![](https://t9016373936.p.clickup-attachments.com/t9016373936/8a7ea04d-ad6c-4aea-afbe-8bde146583f5/image.png)

  

```java
//LinkedHashMap for each method implementation

public final void forEach(Consumer<? super V> action) {
    if (action == null)
        throw new NullPointerException();
    int mc = modCount;
    if (reversed) {
        for (LinkedHashMap.Entry<K,V> e = tail; e != null; e = e.before)
            action.accept(e.value);
    } else {
        for (LinkedHashMap.Entry<K,V> e = head; e != null; e = e.after)
            action.accept(e.value);
    }
    if (modCount != mc)
        throw new ConcurrentModificationException();
}
```

  
  

```java
package CollectionFramework.MapInterface;

import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.Map;

public class LinkedHashMapExample {
    public static void main(String[] args){
        System.out.println("------Below is LinkedHasMap insertion order maintained----->");
        Map<Integer,String> map = new LinkedHashMap<>();
        map.put(1,"A");
        map.put(21,"B");
        map.put(23,"C");
        map.put(141,"D");
        map.put(25,"E");
        map.forEach((Integer key,String val)->System.out.println(key+" : "+val));

        System.out.println("------Below is Normal HasMap insertion order not maintained----->");

        Map<Integer,String> map2 = new HashMap<>();
        map2.put(1,"A");
        map2.put(21,"B");
        map2.put(23,"C");
        map2.put(141,"D");
        map2.put(25,"E");
        map2.forEach((Integer key,String val)->System.out.println(key+" : "+val));
        
    }
}

output:
------Below is LinkedHasMap insertion order maintained----->
1 : A
21 : B
23 : C
141 : D
25 : E
------Below is Normal HasMap insertion order not maintained----->
1 : A
21 : B
23 : C
25 : E
141 : D

Process finished with exit code 0
```

  

**LinkedHashMap maintaing insertion order by using Double inked list.**

  

**Now we are talking About Access Order**.

  

```java
/**
 * Constructs an empty insertion-ordered {@code LinkedHashMap} instance
 * with the specified initial capacity and a default load factor (0.75).
 *
 * @apiNote
 * To create a {@code LinkedHashMap} with an initial capacity that accommodates
 * an expected number of mappings, use {@link #newLinkedHashMap(int) newLinkedHashMap}.
 *
 * @param  initialCapacity the initial capacity
 * @throws IllegalArgumentException if the initial capacity is negative
 */
public LinkedHashMap(int initialCapacity) {
    super(initialCapacity);
    accessOrder = false;
}

/**
 * Constructs an empty insertion-ordered {@code LinkedHashMap} instance
 * with the default initial capacity (16) and load factor (0.75).
 */
public LinkedHashMap() {
    super();
    accessOrder = false;
}

/**
 * Constructs an insertion-ordered {@code LinkedHashMap} instance with
 * the same mappings as the specified map.  The {@code LinkedHashMap}
 * instance is created with a default load factor (0.75) and an initial
 * capacity sufficient to hold the mappings in the specified map.
 *
 * @param  m the map whose mappings are to be placed in this map
 * @throws NullPointerException if the specified map is null
 */
public LinkedHashMap(Map<? extends K, ? extends V> m) {
    super();
    accessOrder = false;
    putMapEntries(m, false);
}
```

  

**For maintaing access order you make accessOrder true.**

  

```java
public LinkedHashMap(int initialCapacity,
                     float loadFactor,
                     boolean accessOrder) {
    super(initialCapacity, loadFactor);
    this.accessOrder = accessOrder;
}
```

  
  

```java
package CollectionFramework.MapInterface;

import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.Map;

public class LinkedHashMapExample {
    public static void main(String[] args){
        //now we are talking about access order
        System.out.println("------Below is LinkedHasMap access order maintained----->");
        Map<Integer,String> map3 = new LinkedHashMap<>(16,.75f,true);
        map3.put(1,"A");
        map3.put(21,"B");
        map3.put(23,"C");
        map3.put(141,"D");
        map3.put(25,"E");
        System.out.println("-----Actual insertion order------");
        map3.forEach((Integer key,String val)->System.out.println(key+" : "+val));


        //access the data 23 most frequently used data will be added in last
        map3.get(23);

        System.out.println("access the data 23 most frequently used data will be added in last");
        map3.forEach((Integer key,String val)->System.out.println(key+" : "+val));


    }
}
output:
------Below is LinkedHasMap access order maintained----->
-----Actual insertion order------
1 : A
21 : B
23 : C
141 : D
25 : E
access the data 23 most frequently used data will be added in last
1 : A
21 : B
141 : D
25 : E
23 : C

Process finished with exit code 0


```

  
  

**get Implementation by LinkedHasMap**

```java
public V get(Object key) {
    Node<K,V> e;
    if ((e = getNode(key)) == null)
        return null;
    if (accessOrder)
        afterNodeAccess(e);
    return e.value;
}
```

  

```java
// Called after update, but not after insertion
void afterNodeAccess(Node<K,V> e) {
    LinkedHashMap.Entry<K,V> last;
    LinkedHashMap.Entry<K,V> first;
    if ((putMode == PUT_LAST || (putMode == PUT_NORM && accessOrder)) && (last = tail) != e) {
        // move node to last
        LinkedHashMap.Entry<K,V> p =
            (LinkedHashMap.Entry<K,V>)e, b = p.before, a = p.after;
        p.after = null;
        if (b == null)
            head = a;
        else
            b.after = a;
        if (a != null)
            a.before = b;
        else
            last = b;
        if (last == null)
            head = p;
        else {
            p.before = last;
            last.after = p;
        }
        tail = p;
        ++modCount;
    } else if (putMode == PUT_FIRST && (first = head) != e) {
        // move node to first
        LinkedHashMap.Entry<K,V> p =
            (LinkedHashMap.Entry<K,V>)e, b = p.before, a = p.after;
        p.before = null;
        if (a == null)
            tail = b;
        else
            a.before = b;
        if (b != null)
            b.after = a;
        else
            first = a;
        if (first == null)
            tail = p;
        else {
            p.after = first;
            first.before = p;
        }
        head = p;
        ++modCount;
    }
}
```

  

**In caching we can used Linked HasMap for recently used items.**

  

*   Time complexity is same as of O(1) for average
*   worst cast O(n) incase of linkedlist and log(N) in case of red-black tree.
*   **Not Thread Safe**
*   so we have ecplicitly make this collection thread safe like ths:

**Map<Integer,Integer> mp = new Collections.synchronizedMap(new LinkedHashMap<>());**

  

**TreeMap**:

  

*   Map I ➝ SortedMap I ➝ NavigableMap I ➝ implements TreeMap concrete class
*   Map is sorted according to it's natural ordering of it's key or by comparator provided.
*   it based on RED-BLACK tree \[Self balancing binary search tree \]
*   average O(logn) time complexity of insert, remove ,get operation.

  

```java
package CollectionFramework.MapInterface;

import java.util.Map;
import java.util.TreeMap;

public class TreeMapExample {

    public static void main(String[] arga){
        Map<Integer,String> mp = new TreeMap<>((k1,k2)->k2-k1);
        mp.put(21,"lola");
        mp.put(11,"pola");
        mp.put(12,"sunny");
        mp.put(5,"luffy");

        //decending order
        System.out.println("decending order");
        mp.forEach((k,v)->System.out.println(k+" : "+v));

        Map<Integer,String> map = new TreeMap<>();
        map.put(21,"lola");
        map.put(11,"pola");
        map.put(12,"sunny");
        map.put(5,"luffy");

        //decending order
        System.out.println("natural or ascending order for integer key");
        map.forEach((k,v)->System.out.println(k+" : "+v));


    }
}
output:
decending order
21 : lola
12 : sunny
11 : pola
5 : luffy
natural or ascending order for integer key
5 : luffy
11 : pola
12 : sunny
21 : lola

Process finished with exit code 0
```

  
  
  

![](https://t9016373936.p.clickup-attachments.com/t9016373936/094e31f1-36c8-4dea-9d30-115ee802677a/image.png)

  

**Methods Avilable In sorted Map.**

*       *   SortedMap<K,V> headMap(K toKey);
    *   SortedMap<K,V> talMap(K toKey);
    *   k firstKey()
    *   k lastKey()

  
  

```java
package CollectionFramework.MapInterface;

import java.util.Map;
import java.util.SortedMap;
import java.util.TreeMap;

public class TreeMapExample {

    public static void main(String[] arga){
        
        System.out.println("Sorted Map ");
        SortedMap<Integer,String> smp = new TreeMap<>();
        smp.put(21,"lola");
        smp.put(11,"p3");
        smp.put(13,"nana");
        smp.put(5,"12");

        System.out.println("smp.headMap(13) exclusive: "+smp.headMap(13));



        System.out.println("smp.tailMap(13) inclusive: "+smp.tailMap(13));


        System.out.println("smp.firstKey(): "+smp.firstKey());
        System.out.println("smp.lastKey(): "+smp.lastKey());


    }
}
output:
Sorted Map 
smp.headMap(13) exclusive: {5=12, 11=p3}
smp.tailMap(13) inclusive: {13=nana, 21=lola}
smp.firstKey(): 5
smp.lastKey(): 21
```

  
  

Methods Avaialble in Navigable Map

*   Map.Entry<K,V> lowerEntry(K key);

  

![](https://t9016373936.p.clickup-attachments.com/t9016373936/81722e9e-211a-4c49-8356-f08579420a6f/image.png)

  
  

![](https://t9016373936.p.clickup-attachments.com/t9016373936/eab85b20-794d-4e20-99df-a9ddc713b4fb/image.png)

  
  

**SET**:

**Few Properties Of Set**

*   Collections of object , but does not contain duplicate value one null value you can insert.
*   UnLike List , Set is not an ordered collection , means it does not follow the insertion order.
*   Unlike List, Set can not be accessed via index.

Few question should have come to your mind.

1. What Data Structure is used in Stack internally( as ti does not allow duplicate values.
2. As order is not gurantee, than what if we want to sort the set collection

Methods In Set

*   add(E element)

➝return true if insert an element in the set and if element is already present it return fasle.

*   addAll(Collection c)

➝perform union of two set collection

  

*   removeAll(Collection c)

➝performs DIFFERENCE of 2 set collection. Delete the values from set which are present in another set.

  

*   retainAll(Collection c)

➝performs Intersection of 2 set collection.

*   clear(), equals(), stream(), parallelStream() and iterator()

  

**HashSet**.

*   Implement Set Interface
*   internally used data structure is HashMap

➝HashMap<E, Object> m = new HashMap<>();

*   During Add method Invocation, it stored the element in the key part and in value it stores dummy object:

➝ map.put(element,new Object())

➝ What if 2 values get the same hash value? how it's handled what is load factor.

*   No gurantee that the order will remain constant.
*   HashSet is not threadSafe > newKeySet method present in ConcurentHashMap class is used to create threadSafe Set.

  

```java
package CollectionFramework.MapInterface;

import java.util.HashSet;
import java.util.Set;

public class SetOrHashSetExample {
    public static void main(String[] args){
        Set<Integer> s = new HashSet<>();
        s.add(11);
        s.add(9);
        s.add(33);
        s.add(-1);

        Set<Integer> s2 = new HashSet<>();
        s2.add(11);
        s2.add(88);
        s2.add(12);
        s2.add(33);
        s.add(0);
        s2.add(null);

        //union
        System.out.println("union of 2 set");
        s.addAll(s2);
        System.out.println("After union");
        s.forEach((v)->System.out.print(v+" "));

        //intersection
        s=new HashSet<>();
        s.add(12);
        s.add(33);
        s.add(88);
        s.add(99999);

        s2 = new HashSet<>();
        s2.add(0);
        s2.add(99999);
        s2.add(null);
        s2.add(-1);
        s2.add(88);

        System.out.println("After Intersection");
        s.retainAll(s2);
        s.forEach((v)->System.out.println(v));


        //difference
        s=new HashSet<>();
        s.add(12);
        s.add(33);
        s.add(88);
        s.add(99999);

        s2 = new HashSet<>();
        s2.add(0);
        s2.add(99999);
        s2.add(null);
        s2.add(-1);
        s2.add(88);
        s.removeAll(s2);
    }
}
```

  

*   duplicate element allowed ➝ no

  
  
  
  
  
  

```java
package CollectionFramework.MapInterface;

import java.util.Iterator;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;

public class ThreadSafeSetExample {
    public static void main(String[] args){
        ConcurrentHashMap concurrentHashMap = new ConcurrentHashMap<>();

        Set<Integer> threadSafeSet =concurrentHashMap.newKeySet();

        threadSafeSet.add(0);
        threadSafeSet.add(1);

        Iterator<Integer> it = threadSafeSet.iterator();

        while(it.hasNext()){
            Integer val = it.next();
            if(val==1){
                //it.remove() :-we cam remove
                threadSafeSet.add(9);
                //we should be able to add because it is thread safe
                // In case Of simple set we cannot be able to do
            }
        }
        threadSafeSet.forEach((val)->System.out.println(val));

    }
}
output:
0
1
9

Process finished with exit code 0


```

  

Time complextity

*   add: O(1)
*   remove: amortized or average O(1)
*   contains : average or amortized O(1)

  

**LinkedHasSet**.

➝Internally using : LinkedHashMap

➝ maintains insertion order

➝ NOT MAINTAIN ACCESS ORDER.

➝ its not thread safe

Set<Integer> s = Collections.synchronizedMap(new LinkedHashSet<>());

*   Time complexity average will same as linkedHashmap red-black tree O(logN) and incase of LinkedList it O(n) worst case

  

```java
package CollectionFramework.MapInterface;

import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.Set;

public class LinkedHashSetExample {
    public static void main(String[] args){
        Set<Integer> s = new LinkedHashSet<>();

        s.add(34);
        s.add(2);
        s.add(0);
        s.add(9999);

        System.out.println("Maintain Insertion Order");

        Iterator<Integer> it = s.iterator();
        while (it.hasNext()){
            System.out.println(it.next());
        }
    }
}
output:
34
2
0
9999

Process finished with exit code 0
```

  
  
  

**TreeSet**:

*   internally it uses TreeMap.
*   it can not store null value
*   It uses red-black or balanced binary search tree

  

```java
package CollectionFramework.MapInterface;

import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;
import java.util.TreeSet;

public class TreeSetExample {
    public static void main(String[] args){
        //We can also provide comparator here.
        Set<Integer> s = new TreeSet<>();
        s.add(11);
        s.add(9);
        s.add(33);
        s.add(-1);
        Iterator<Integer> it = s.iterator();
        while (it.hasNext()){
            System.out.println(it.next());
        }


    }
}
output:
-1
9
11
33

Process finished with exit code 0
```